# 쿠키 구입 

## 1. 문제 설명 

과자를 바구니 단위로 파는 가게가 있습니다. 이 가게는 1번부터 N번까지 차례로 번호가 붙은 바구니 N개가 일렬로 나열해 놨습니다.

철수는 두 아들에게 줄 과자를 사려합니다. 첫째 아들에게는 l번 바구니부터 m번 바구니까지, 둘째 아들에게는 m+1번 바구니부터 r번 바구니까지를 주려합니다. 단, 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N). 즉, A[i] 를 i번 바구니에 들어있는 과자 수라고 했을 때, A[l]+..+A[m] = A[m+1]+..+A[r] 를 만족해야 합니다.

각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때, 조건에 맞게 과자를 살 경우 한 명의 아들에게 줄 수 있는 가장 많은 과자 수를 return 하는 solution 함수를 완성해주세요. (단, 조건에 맞게 과자를 구매할 수 없다면 0을 return 합니다)

> 제한 사항

* cookie의 길이는 1 이상 2,000 이하입니다.
* cookie의 각각의 원소는 1 이상 500 이하인 자연수입니다.

## 2. 입출력 예

| cookie    | result   |
|-----------|----------|
| \[1,1,2,3]| 3       |
| \[1,2,4,5]| 0       |

> 입출력 예 설명

입출력 예 #1

첫째 아들에게 2, 3번 바구니를, 둘째 아들에게 4번 바구니를 사주면 두 아들은 각각 과자 3개를 받습니다.

입출력 예 #2

주어진 조건에 맞게 과자를 살 방법이 없습니다.

## 3. 문제 풀이

첫번째 조건 :
<br> 첫째 아들이 받을 과자 수 : l번 바구니부터 m 번 바구니까지의 과자 총 수 
<br> 둘째 아들이 받을 과자 수 : m+1번 바구니부터 r번 바구니까지의 과자 총 수 
<br> 단, ( 1 <= l <= m , m+1 <= r <= N ) 

두번째 조건 :
<br> 첫째 아들과 둘째 아들이 받을 과자 수는 같아야 한다. 

> m 과 m + 1 에 초첨을 맞추자

첫째 아들은 m번째 바구니의 쿠키를 무조건 가져야하고, 둘째 아들은 m+1번째 바구니의 쿠기를 무조건 가져야 한다. <br>
( 1 <= l <= m 이고 m+1 <= r <= N 이라 l은 m과 같을 수 있고 , r 도 m+1 과 같을 수 있기에)
<br>따라서 첫째아들이 m번째를 바구니의 쿠키를 갖고 둘째아들이 m+1번째 바구니의 쿠기를 갖는 것 부터 시작하자. 

> 쿠키의 개수가 최대인 것을 구해야 한다. 따라서 첫째 아들이 가질 수 있는 바구니와 둘째 아들이 가질 수 있는 바구니를 끝까지 탐색해야 한다. 

만약 바구니 배열이 \[1,1,2,3]이고 m 이 2 라면 위의 글에 따라 첫째 아들은 2번째 바구니를 갖고 둘째 아들은 3번째 바구니를 갖는 것부터 시작한다. 이후 첫째아들이 가질 수 있는 것은 1번째 바구니 , 둘째 아들이 가질 수 있는 것은 4번째 바구니이다. 요렇게 첫째 아들은 배열의 왼편으로 둘째아들은 배열의 오른편으로 끝까지 탐색하면서 쿠키의 최대 개수를 구해야 한다. 

> 현재 쿠키의 수가 서로 같은 경우 , 첫째 아들이 많은 경우 , 둘째 아들이 많은 경우

1. 현재 쿠키의 수가 서로 같은 경우

탐색하다 쿠키의 수가 같을 수 있다. 이때는 지금까지 구한 최대 쿠기 수와 비교해 더 크면 최대 쿠기 수에 할당한다. 그리고 아직 탐색이 끝난 것이 아니므로 양쪽을 모두 탐색하여 바구니의 수를 더한다. 

2. 첫째 아들이 쿠키의 수가 더 많은 경우 
: 서로 같아야 하므로 둘째아들 쪽에서 오른편으로 탐색하여 바구니의 수를 더한다.(첫째 아들의 쿠기 수와 같아지려면 둘째 아들 쪽에서 더해야 하므로 )  

3. 둘째 아들이 쿠키의 수가 더 많은 경우
: 서로 같아야 하므로 첫째아들 쪽에서 오른편으로 탐색하여 바구니의 수를 더한다.(둘째 아들의 쿠기 수와 같아지려면 첫째 아들 쪽에서 더해야 하므로 )  

## 4. 코드

```java
public int solution(int[] cookie) {
        int answer = 0;
        int len = cookie.length;
        for(int m = 0; m < len -1 ; m++){
            int aSum = cookie[m];
            int t = 1;

            int n = m + 1;
            int bSum = cookie[n];
            int k = 1;

            while(true){
                // 쿠기 수가 같은 경우 
                if(aSum == bSum){
                    if(answer < aSum){
                        answer = aSum;
                    }                 

                    // move left and right 
                    if(m - t >= 0 && n + k < len){
                        aSum += cookie[m - t];
                        t++;       
                        bSum += cookie[n + k];
                        k++;
                    }else {
                        break; 
                    }
                } else if (aSum < bSum){
                    // move left
                    if(m - t >= 0){
                        aSum += cookie[m - t];
                        t++;       
                    }else {
                        break; 
                    }                    
                } else {
                    // move right
                    if(n + k < len){
                        bSum += cookie[n + k];
                        k++;       
                    }else {
                        break; 
                    }                                        
                }
            }            
        }

        return answer;
    }

```
