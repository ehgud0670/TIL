# graph(그래프)의 표현

vertex- 정점 <br>
edge - 간선 <br>
element - 원소 <br>

Undirected graph - 무방향 그래프<br>
Directed graph - 유향 그래프 <br>

* 그래프를 표현하는데 인접행렬(Adjacency Matrix)와 인접리스트(Adajacency List)가 있다.

## 인접행렬을 이용한 방법
* 물론 인접행렬은 자료구조 중 배열을 사용한다.
그래프 G=(V,E) 에서 V(정점)의 총 개수를 n이라 하자. 인접행렬을 이용하려면 n X n 행렬을 준비한다.<br>
정점 i 와 정점 j 간에 간선이 있으면 행렬의 (i,j)원소와 (j,i)원소의 값에 1을 할당하고,<br>
만약 정점 i,j 사이에 간선이 없다면 행렬의 (i,j)원소와 (j,i)원소의 값에 0을 할당한다. <br>
그리고 간선에 가중치(weight)이 있다면 1이 아닌 가중치의 값을 넣으면 된다. <br>

Undirected graph를 표현한다면, Undirected graph는 두 원소 사이에 edge가 무조건 1개 혹은 0개이므로 <br>
행렬이 대각선(i,i)을 기준으로 대칭을 이루지만,<br>
Directed graph는 간선이 방향성을 갖고 있으므로 대각선(i,i)을 기준으로 대칭을 이루지 않는다.<br>

#### 인접행렬은 간선의 유무를 변수의 값을 통해 표현할 수 있고, 간선의 총 개수도 쉽게 구할 수 있다. 

인접행렬은 총 노드들의 간선의 개수가 많은 경우라면 그래프를 표현하는데 적합하지만,<br>
총 간선의 개수가 적은 경우라면 효율적이지 못하다. <br>
왜냐하면 간선이 있으면 간선의 weight크기, 없으면 0을 각 정점마다 할당해야 하므로 채우는대만 O(n^2)의 시간이 들고,<br>
공간도 그만큼 크게 소비되는데, 간선의 개수가 별로 없다면 시간과 공간이 많이 낭비되기 때문에 간선이 많은 경우에만 <br>
인접행렬을 사용하는 게 효율적이다.<br>
(100만개의 정점을 가진 undirected graph에서 간선의 유무를 표현하는데 1조개의 원소가 필요하다.(100만 x 100만) <br>
근데 이중에 간선이 200만개 밖에 없다면 나머지(1조개 - 200만)는 0을 채우므로 시간과 공간이 의미없게 크게낭비된다.<br>
==> 이 경우는 인접리스트를 사용하면 된다.<br>



## 인접리스트를 이용한 방법
* 물론 인접리스트는 자료구조 중 연결리스트(Linked List)를 사용한다.

인접리스트(Adjacency List) 표현법은 각 정점에 인접한 vertex들을 리스트로 표현하는 방법이다.<br>
각 vertex마다 리스트를 하나씩 만들고, 여기에 각 vertex에 인접한 vertex들을 연결리스트(Linked List)로 매단다.<br>

Undirected graph의 경우에는 인접리스트로 표현한다면 일단 간선 하나당 2개의 노드가 생성되고,<br> 
Directed graph의 경우에는 인접리스트로 표현한다면 간선 하나당 1개의 노드가 생성되고, <br>

또 가중치가 없는 그래프이 경우에는 노드가 <정점의 번호, 다음 정점의 포인터> 로 구성되고,  
가중치가 있는 그래프의 경우에는  노드가 <정점의 번호 ,가중치(weight)의 크기, 다음 정점의 포인터> 로 구성된다. <br>

#### 인접리스트는 간선의 유무를 각 정점의 리스트의 연결된 리스트들의 value 값을 알아야만 알 수 있고,
#### 간선의 총 개수도 리스트를 돌며 중복되지 않게(체크한 정점의 정보를 따로 배열에 저장해야함)로직을 짜야지만 개수를 알 수 있다. (간선의 관점에서 연결리스트는 어렵다.) 

만약 총 간선의 개수가 적은 경우라면 효율적이다. <br>
왜냐하면 인접리스트는 연결리스트로 서로 간선이 있는 정점끼리만 연결을 하면 되기 때문에, (인접행령의 경우는 간선이 없는 경우 0을 할당한다.)<br>공간 자체가 간선의 개수에 비례하므로 간선이 적다면 공간을 많이 차지 하지 않기 때문이다.<br>
그리고 간선의 개수도 로직을 짜서 구하면 되기에 인접행렬보다 효율적이다.<br>
왜냐하면 인접행렬의 경우 만드는데만 O(n^2)의 시간이 걸리지만 , 간선의 개수를 구하는 로직이 더 번거롭지만 O(n^2) 보다 훨씬 효율적이기 때문이다.<br>
그렇지만 모든 정점 쌍에 대해 간선이 존재하는 경우 각 정점마다 연결리스트를 (정점의 개수-1) 만큼 만들어야 하기 때문에, <br>
오버헤드가 (공간 x , 시간 x) 많이 생기기 때문에 이런 경우에는 인접행렬을 사용하도록 하자. <br>
(각 정점당 연결리스트를 정점의 개수-1 만큼 만들려면 O(n^2)가 걸리고 간선 파악도 힘들기 때문이다.)<br>




