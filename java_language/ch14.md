## chapter 14
## 람다식

> 람다식이란? 
```java
Runnable runnable = () -> {...}; // 람다식
```
* 위 코드는 Runnable 변수에 대입되므로 람다식은 Runnable의 익명 구현 객체를 생성하게 된다.

=>람다식은 함수적 프로그래밍 언어로 "(매개변수)->{실행코드}" 형태로 작성된다. **병렬 처리와 이벤트 지향 프로그래밍**에 적합한 언어로 자바에서는 한때는 주목받지 못하다가 요즘들어 다시 각광받고 있다. 각광받는 이유는 람다식을 사용하면 자바 코드가 간결해지고, 컬렉션의 요소를 필터링하거나 매핑해서 원하는 결과를 쉽게 집계할 수 있기 때문이다.

* 람다식은 마치 함수 정의 형태를 띠고 있지만, 런타임 시에 인터페이스의 익명 구현 객체로 생성됨을 명심하자. **어떤 인터페이스가 구현될 것인가는 대입되는 인터페이스가 무엇이냐**에 달려있다. 



> 타겟 타입과 함수적 인터페이스

=> 람다식의 형태가 매개변수가 있는 블록이기 때문에 마치 자바에서 직접 메소드를 선언한 것처럼 보이지만 **자바는 메소드를 단독으로 선언 할 수 없기 때문에**람다식은 단순히 메소드를 선언하는 것이 아니라 **이 메소드를 가지고 있는 객체**를 생성해낸다.(명심!)<br>  

```java
인터페이스 변수 = 람다식; 
```

* 람다식은 인터페이스의 종류에 따라 작성 방법이 달라지기 때문에 람다식이 대입될 인터페이스를 람다식의 타겟 타입(target type)이라고 한다. 


### 함수적 인터페이스(@FunctionalInterface)

=> 모든 인터페이스는 람다식의 타켓 타입으로 사용할 수 없다. 람다식이 하나의 메소드를 정의하기 때문에 **두 개 이상의 추상메소드가 선언된 인터페이스는 람다식을 이용해서 구현 객체를 생성할 수 없다.** 하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있는데 , 이러한 인터페이스를 함수적 인터페이스(functional interface)라고 한다. 

* 하나의 추상메소드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있고 이러한 인터페이스를 함수적 인터페이스(functional interface)라고 한다. 

* 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능이 있는데, 인터페이스 선언 시 @FunctionalInterface 어노테이션을 붙이면 된다. 이 어노테이션은 두 개 이상의 추상 메소드가 선언되면 컴파일 오류가 발생시킨다.  
=> @FunctionInterface 어노테이션은 선택사항이다. 단, 실수로 두 개이상의 추상 메소드를 선언하는 것을 방지하고 싶다면 붙여주는 것이 좋다.


리턴값과 매개변수가 없는 람다식 <br>
``java
public interface MyFunctionalInterface {
	void method(); // 추상 메소드
	public static void main(String[] args) {

		//매개변수와 리턴 값이 없는 메소드
		MyFunctionalInterface fi = ()->{
			System.out.println("hello");
		};
		fi.method();
	}
}
```

매개변수가 있는 람다식 <br>
```java
public interface ParameterInterface {

	//매개변수가 있는 추상 메소드
	void method(int x);

	public static void main(String[] args) {
		//매개변수가 하나인 경우에는 괄호를 생략할 수 있다.
		ParameterInterface fi = x-> System.out.println("hello "+x);

		fi.method(5);
	}
}
```

리턴값이 있는 람다식 <br>
```java
public interface ReturnInterface {
	//리턴 값이 있는 추상 메소드
	int method();


	public static void main(String[] args) {
		//리턴값이 있는 람다식
		ReturnInterface fi = ()->{
			return 5;
		};

		int x = fi.method();
		System.out.println("hello "+ x);
	}

}
```

매개변수와 리턴값이 있는 람다식 <br>
```java

public interface ParameterReturnInterface {
	//리턴값과 매개변수가 둘다 있는 추상 메소드
	int add(int x, int y);

	public static void main(String[] args) {
		// 리턴값과 매개변수가 있는 람다식
		ParameterReturnInterface fi = (x, y) ->{
			return x+y;
		};

		int result = fi.add(3,5);

		System.out.println("3 과 5를 더하면 " + result+ "입니다.");
	}

}
```

### 클래스 멤버와 로컬 변수 사용 

> 클래스의 멤버 사용

=> 람다식 실행 블록에는 클래스의 멤버인 필드와 메소드를 제약 없이 사용할 수 있는데, this의 사용에는 주의를 기울이자. 일반적으로 익명 객체 내부에서 this는 익명 객체의 참조이지만, 람다식에서 this는 내부적으로 생성되는 익명 객체의 참조가 아니라 **람다식을 실행한 객체의 참조**이다.

```java
public class UsingThis{
	public int outterfield = 10;

	class Inner{
	  int innerField = 20;

	  void method(){
      //Ramda 
      MyFunctionInterface fi = () -> {
       
        /* 람다식에서의 this는 내부적으로 생성되는 익명 객체의 참조가 아니라 람다식을 실행한 객체의 참조이다. 즉 Inner 클래스 인스턴스의 참조이다 .*/ 

        //바깥 객체의 참조를 얻기 위해서는 클래스명 this를 사용
        System.out.println("outterField: " + UsingThis.this.outterField + "\n");
        
        
        //람다식 내부에서 this는 Inner 객체를 참조
        System.out.println("innnerField: " + this.innerField + "\n");

			};

		}
	
	}

}
```

> 로컬 변수 사용 

* 람다식에서 바깥 클래스의 필드나 메소드는 제한 없이 사용할 수 있으나, 메소드의 매개 변수 또는 로컬 변수를 사용하면 이 두 변수는 final 특성을 가져야 한다. (매개변수나 로컬 변수는 함수가 종료되면 소멸되고 도중에 값이 바뀌면 안되므로 final 적인 특성을 가져야 한다.)

```java
public class UsingLocalVariable {
	void method(int arg){ //arg는 매개변수이기 때문에 final 한 특성을 가짐.
    int localVar = 40; // localVar은 로컬 변수이기 때문에 final한 특성을 가짐

 
    //arg = 5;(x) : arg는 람다식에서 사용하므로 매개변수로서 final한 특성을 가져야 하므로 값이 변경될 수 없다.
    //localVar = 20;(x) : localVar 은 람다식에서 사용하므로 로컬 변수로서 final한 특성을 가져야 하기 때문에 값이 변경 될 수 없다.

    MyFunctionalInterface fi = () ->{
      //로컬 변수 읽기
      System.out.println("arg: " + arg);
      System.out.println("localVar: " + localVar);
		};
    fi.method();
	}
```


### 표준 API의 함수적 인터페이스

* 자바에서 제공되는 표준 API에서 한개의 추상 메소드를 가지는 인터페이스는 모두 람다식이 적용 가능하다. 예를 들어 스레드의 작업을 정의하는 **Runnable 인터페이스**는 매개변수와 리턴값이 없는 **run()**메소드만 존재하기 때문에 다음과 같이 람다식을 이용해서 Runnable 인스턴스를 생성시킬 수 있다. 

```java
public class RunnableExample {

  public static void main(String args[]){
    
    // 이 람다식은 Runnable 인터페이스의 run() 메소드를 나타낸다.
    // 즉, 스레드가 실행하는 코드이다.
    Runnable runnable = () ->{
      for(int i=0; i<10; i++){
         System.out.println(i);

			}

		};

    Thread thread = new Thread(runnable);
    thread.start();


  }
}

* **Thread 생성자를 호출할 때 다음과 같이 람다식을 매개값으로 대입해도 된다.(대입하자)**

```java
Thread thread = new Thread(()->{
  for(int i=0; i<10; i++){
    System.out.println(i);
	}

});
```

* 자바 8부터는 빈번하게 사용되는 함수적 인터페이스(functional interface)는 java.util.function 표준 API 패키지로 제공된다. java.util.function 패키지의 함수적 인터페이스는 크게 Consumer, Supplier, Function, Operator, Predicate 로 구분된다. 구분 기준은 인터페이스에 선언된 **추상 메소드의 매개값과 리턴값의 유무**이다.

| 종류     | 추상 메소드 특징             |
|----------|------------------------------|
| Consumer | -매개값은 있고, 리턴값은 없음|
| Supplier | -매개값은 없고, 리턴값은 있음|
| Function | -매개값도 있고, 리턴값도 있음 |
| | -주로 매개값을 리턴값으로 매핑(타입 변환)|
| Operator | -주로 매개값도 있고, 리턴값도 있음 |
| | -주로 매개값을 연산하고 결과를 리턴 |
| Predicate | -매개값은 있고, 리턴 타입은 boolean |
|  |  -매개값을 조사해서 true/false를 리턴 |

> Consumer 함수적 인터페이스 

=> Consumer 함수적 인터페이스의 특징은 리턴값이 없는 accept() 메소드를 가지고 있다. **accept() 메소드는 단지 매개값을 소비하는 역할만 한다.** 여기서 소비한다는 말은 사용만 할 뿐 리턴값이 없다는 뜻이다.<br>

* 매개 변수의 타입과 수에 따라서 아래와 같은 Consumer들이 있다.

| 인터페이스명 | 추상 메소드                | 설명                                |
|--------------|----------------------------|-------------------------------------|
| Consumer\<T>  | void accept(T t)           | 객체 T를 받아 소비                  |
| BiConsumer\<T,U> | void accept(T t, U u) | 객체 T 와 U 를 받아 소비         | 
| DoubleConsumer | void accept(double value) | double 값을 받아 소비 |
| IntConsumer  | void accept(int value) | int 값을 받아 소비 |
| LongConsumer | void accept(long value) | long 값을 받아 소비 |
| ObjDoubleConsumer\<T> | void accept(T t, double value) | 객체 T 와 double 값을 받아 소비 |
| ObjIntConsumer\<T> | void accept(T t, int value) | 객체 T 와 int 값을 받아 소비 |
| ObjLongConsumer\<T> | void accept(T t, Long value) | 객체 T 와 long 값을 받아 소비 |

예제<br>
```java
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.ObjIntConsumer;

public class ConsumerExample {
    public static void main(String[] args) {
        Consumer<String> consumer = t -> System.out.println(t + "8");
        consumer.accept("java");

        BiConsumer<String, String> biConsumer = (t,u) -> System.out.println(t+u);
        biConsumer.accept("java","8");

        DoubleConsumer doubleConsumer = (t) -> System.out.println("java"+t);
        doubleConsumer.accept(8.0);

        ObjIntConsumer<String> objIntConsumer = (t,i) -> System.out.println(t+i);
        objIntConsumer.accept("java",8);
    }
}
```

> Supplier 함수적 인터페이스

=> Supplier 함수적 인터페이스의 특징은 매개 변수가 없고 리턴값이 있는 getXXX() 메소드를 가지고 있다. **이 메소드들은 실행 후 호출한 곳으로 데이터를 리턴(공급)하는 역할을 한다.**

| 인터페이스 형      | 추상 메소드             | 설명                        |
|--------------------|-------------------------|-----------------------------|
| Supplier\<T> | T 	get()| T 객체를 리턴 |  T 객체를 리턴 | 
| BooleanSupplier | boolean getAsBoolean() | boolean 값을 리턴  |
| DoubleSupplier | double getAsDouble() | double 값을 리턴 |
| IntSupplier | int getAsInt() | int값을 리턴 | 
| LongSupplier | long getAsLong() | long값을 리턴 | 

```java

import java.util.function.IntSupplier;

public class SupplierExample {

    public static void main(String[] args) {
        IntSupplier intSupplier = ()->{
            //1~6에서 random한 숫자가 나올 것.
            return (int)(Math.random()*6) + 1;
        };

        int num = intSupplier.getAsInt();
        System.out.println(num);
    }
```

> Functuon 함수적 인터페이스 

=> Function 함수적 인터페이스의 특징은 매개값과 리턴값이 있는 applyXXX() 메소드를 가지고 있다. **이 메소드들은 매개값을 리턴값으로 매핑(타입 변환)하는 역할을 한다.**

| 인터페이스명 | 추상 메소드 | 설명                      |
|--------------|-------------|---------------------------|
| Function\<T,R> | R apply(T t) | 객체 T를 객체 R로 매핑 |
| BiFunction\<T,U,R> | R apply(T t,U u) |객체 T와 U를 객체 R로 매핑 |
| DoubleFunction\<R> | R apply(double value )| double을 객체 R 로 매핑 |
| IntFunction\<R> | R apply(int value) | int를 객체 R로 매핑 |
| IntToDoubleFunction| double applyAsDouble(int value) | int를  double 로 매핑 |
| IntToLongFunction | long applyAsLong(int value) | int를 long으로 매핑 |
| LongToDoubleFunction | double applyAsDouble(long value) | long을 double로 매핑 |
| LongToIntFunction | double applyAsDouble(long value) | long을 double로 매핑 | 
| ToDoubleBiFunction\<T,U> | double applyAsDouble(T t, U t) | 객체 T와 U를 double로 매핑 |
| ToDoubleFunction\<T> | double applyAsDouble(T t) | 객체 T를 double로 매핑 |
| ToIntBiFunction\<T,U> | int applyAsInt(T t, U t) | 객체 T와 U를 int로 매핑 |
| ToIntFunction\<T> | int applyAsInt(T t, U t) | 객체 T를 int로 매핑 |
| ToLongBiFunction\<T,U> | long applyAsLong(T t, U t) | 객체 T와 U를 long으로 매핑 |
| ToLongFunction\<T,U> | long applyAsLong(T t) | 객체 T를 long으로 매핑 |

> Operator 함수적 인터페이스 

=> Operator 함수적 인터페이스는 Function 와 동일하게 매개 변수와 리턴 값이 있는 applyXXX() 메소드를 가지고 있다. 하지만 이 메소드들은 매개값을 리턴값으로 매핑(타입 변환)하는 것보다 매개값을 이용해서 연산을 수행한 후 **동일한 타입**으로 리턴값을 제공하는 역할을 한다.<br>

| 인터페이스명        | 추상 메소드                      | 설명                            |
|---------------------|----------------------------------|---------------------------------|
| BinaryOperator\<T> | T apply(T t, T t) |  T와 T를 연산한 후 T 리턴|
| UnaryOperator\<T> | T apply(T t) |  T를 연산한 후 T 리턴|
| DoubleBinaryOperator | double applyAsDouble(double ,double) | 두 개의 double 연산 | 
| DoubleUnaryOperator | double applyAsDouble(double) | 한 개의 double 연산 | 
| IntBinaryOperator | int applyAsInt(int , int)  | 두 개의 int 연산 |
| IntUnaryOperator | int applyAsInt(int) |  한 개의 int 연산 | 
| LongBinaryOperator | long applyAsLong(long, long) |  두 개의 long 연산 |
| LongUnaryOperator | long applyAsLong(long) |  한 개의  long 연산 |

> Predicate 함수적 인터페이스 
=> Predicate 함수적 인터페이스는 매개 변수와 boolean 리턴값이 있는 testXXX() 메소드를 가지고 있다. **이 메소드들은 매개값을 조사해서 true 또는 false를 리턴하는 역할을 한다.**<br>

| 인터페이스명    | 추상 메소드          | 설명                       |
|-----------------|----------------------|----------------------------|
| Predicate\<T>   | boolean test(T t) | 객체 T를 조사     |
| BiPredicate\<T,U> | boolean test(T t, U u)| 객체 T 와 U를 조사 |
| DoublePredicate | boolean test(double value) | double 값을 조사 | 
| IntPredicate | boolean test(int value)  |  int 값을 조사  |
| LongPredicate | boolean test(long value) | long 값을 조사 |

> andThen() 과 compose() 디폴트(default) 메소드 

1. Consumer의 순차적 연결
2. Function의 순차적 연결 

> and(),or(), negate() 디폴트 메소드와 isEqual() 정적 메소드 

> minBy(), maxBy() 정적 메소드 

### 메소드 참조

> 정적 메소드와 인스턴스 메소드 참조 

> 매개 변수의 메소드 참조 

> 생성자 참조 


